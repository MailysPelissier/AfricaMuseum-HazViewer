PostgreSQL path : C:\Program Files\PostgreSQL\17
password : password
port : 5432

create extension POSTGIS;

Ajouter couche pays : ne_10m_admin_0_countries.shp (Natural Earth)

Ajouter dans pg Admin :
dans l'invite de commande : 
cd C:\Program Files\PostgreSQL\17\bin
shp2pgsql -s 4326 -c -D -i -I C:\Mailys\data\ne_10m_admin_0_countries\ne_10m_admin_0_countries.shp countries | psql -h localhost -U postgres -d webGIS



Events v3 :

-- Table: public.events2020_23

DROP TABLE IF EXISTS public.events2020_23;

CREATE TABLE IF NOT EXISTS public.events2020_23
(
    id_integer integer,
    event_id character varying COLLATE pg_catalog."default",
    hazard_type character varying COLLATE pg_catalog."default",
    disaster_score real,
    hasard_type_score real,
    latitude real,
    longitude real,
    event_time timestamp without time zone,
    bbox_event character varying COLLATE pg_catalog."default",
    n_languages real,
    n_source_countries real,
    paragraphs_list character varying COLLATE pg_catalog."default",
    articles_list character varying COLLATE pg_catalog."default",
    n_paragraphs real,
    n_articles real,
    start_time timestamp without time zone,
    end_time timestamp without time zone,
    duration integer,
    mostfreq_death real,
    n_mostfreq_death real,
    time_mostfreq_death real,
    max_death real,
    n_max_death real,
    time_max_death real,
    median_death real,
    mostfreq_homeless real,
    n_mostfreq_homeless real,
    time_mostfreq_homeless real,
    max_homeless real,
    n_max_homeless real,
    time_max_homeless real,
    median_homeless real,
    mostfreq_injured real,
    n_mostfreq_injured real,
    time_mostfreq_injured real,
    max_injured real,
    n_max_injured real,
    time_max_injured real,
    median_injured real,
    mostfreq_affected real,
    n_mostfreq_affected real,
    time_mostfreq_affected real,
    max_affected real,
    n_max_affected real,
    time_max_affected real,
    median_affected real,
    mostfreq_missing real,
    n_mostfreq_missing real,
    time_mostfreq_missing real,
    max_missing real,
    n_max_missing real,
    time_max_missing real,
    median_missing real,
    mostfreq_evacuated real,
    n_mostfreq_evacuated real,
    time_mostfreq_evacuated real,
    max_evacuated real,
    n_max_evacuated real,
    time_max_evacuated real,
    median_evacuated real,
    country character varying COLLATE pg_catalog."default",
    wkt character varying COLLATE pg_catalog."default",
    geom geometry(Point,4326),
    primary_key integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    country_found character varying COLLATE pg_catalog."default",
    CONSTRAINT events2020_23_pkey PRIMARY KEY (primary_key)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.events2020_23
    OWNER to postgres;

-- Index: events2020_23_geom_idx

DROP INDEX IF EXISTS public.events2020_23_geom_idx;

CREATE INDEX IF NOT EXISTS events2020_23_geom_idx
    ON public.events2020_23 USING gist
    (geom)
    WITH (buffering=auto)
    TABLESPACE pg_default;

COPY events2020_23(id_integer,event_id,hazard_type,disaster_score,hasard_type_score,latitude,longitude,event_time,bbox_event,n_languages,n_source_countries,paragraphs_list,articles_list,n_paragraphs,n_articles,start_time,end_time,duration,mostfreq_death,n_mostfreq_death,time_mostfreq_death,max_death,n_max_death,time_max_death,median_death,mostfreq_homeless,n_mostfreq_homeless,time_mostfreq_homeless,max_homeless,n_max_homeless,time_max_homeless,median_homeless,mostfreq_injured,n_mostfreq_injured,time_mostfreq_injured,max_injured,n_max_injured,time_max_injured,median_injured,mostfreq_affected,n_mostfreq_affected,time_mostfreq_affected,max_affected,n_max_affected,time_max_affected,median_affected,mostfreq_missing,n_mostfreq_missing,time_mostfreq_missing,max_missing,n_max_missing,time_max_missing,median_missing,mostfreq_evacuated,n_mostfreq_evacuated,time_mostfreq_evacuated,max_evacuated,n_max_evacuated,time_max_evacuated,median_evacuated,country)
FROM 'C:/Mailys/data/S20200101000000_E20240101000000_GDELT_Events_v3.csv'
DELIMITER ',' 
CSV HEADER
QUOTE '"';

UPDATE events2020_23 SET wkt=concat('POINT (',longitude,' ',latitude,')');
UPDATE events2020_23 SET geom=ST_GeomFromText(wkt);
UPDATE events2020_23 SET country_found = c.admin FROM countries c WHERE ST_Contains(c.geom, events2020_23.geom);


Paragraphs v3 :

-- Table: public.paragraphs2020_23

DROP TABLE IF EXISTS public.paragraphs2020_23;

CREATE TABLE IF NOT EXISTS public.paragraphs2020_23
(
    article_id character varying COLLATE pg_catalog."default",
    title character varying COLLATE pg_catalog."default",
    extracted_text character varying COLLATE pg_catalog."default",
    paragraph_time timestamp without time zone,
    article_language character varying COLLATE pg_catalog."default",
    source_country character varying COLLATE pg_catalog."default",
    domain_url character varying COLLATE pg_catalog."default",
    paragraph_id character varying COLLATE pg_catalog."default",
    original_text character varying COLLATE pg_catalog."default",
    disaster_label real,
    disaster_score real,
    hasard_type character varying COLLATE pg_catalog."default",
    hasard_type_score real,
    nb_death real,
    score_death real,
    answer_death character varying COLLATE pg_catalog."default",
    nb_homeless real,
    score_homeless real,
    answer_homeless character varying COLLATE pg_catalog."default",
    nb_injured real,
    score_injured real,
    answer_injured character varying COLLATE pg_catalog."default",
    nb_affected real,
    score_affected real,
    answer_affected character varying COLLATE pg_catalog."default",
    nb_missing real,
    score_missing real,
    answer_missing character varying COLLATE pg_catalog."default",
    nb_evacuated real,
    score_evacuated real,
    answer_evacuated character varying COLLATE pg_catalog."default",
    publication_time timestamp without time zone,
    extracted_location character varying COLLATE pg_catalog."default",
    ner_score character varying COLLATE pg_catalog."default",
    latitude real,
    longitude real,
    std_dev real,
    min_lat real,
    max_lat real,
    min_lon real,
    max_lon real,
    n_locations real,
    nb_death_min real,
    nb_death_max real,
    nb_homeless_min real,
    nb_homeless_max real,
    nb_injured_min real,
    nb_injured_max real,
    nb_affected_min real,
    nb_affected_max real,
    nb_missing_min real,
    nb_missing_max real,
    nb_evacuated_min real,
    nb_evacuated_max real,
    unnamed_column real,
    country character varying COLLATE pg_catalog."default",
    wkt character varying COLLATE pg_catalog."default",
    geom geometry(Point,4326),
    primary_key integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    country_found character varying COLLATE pg_catalog."default",
    CONSTRAINT paragraphs2020_23_pkey PRIMARY KEY (primary_key)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.paragraphs2020_23
    OWNER to postgres;
	
-- Index: paragraphs2020_23_geom_idx

DROP INDEX IF EXISTS public.paragraphs2020_23_geom_idx;

CREATE INDEX IF NOT EXISTS paragraphs2020_23_geom_idx
    ON public.paragraphs2020_23 USING gist
    (geom)
    WITH (buffering=auto)
    TABLESPACE pg_default;
	
-- Index: paragraphs2020_23_paragraph_id_idx

DROP INDEX IF EXISTS public.paragraphs2020_23_paragraph_id_idx;

CREATE INDEX IF NOT EXISTS paragraphs2020_23_paragraph_id_idx
    ON public.paragraphs2020_23 USING btree
    (paragraph_id ASC NULLS LAST)
    TABLESPACE pg_default;

COPY paragraphs2020_23(article_id,title,extracted_text,paragraph_time,article_language,source_country,domain_url,paragraph_id,original_text,disaster_label,disaster_score,hasard_type,hasard_type_score,nb_death,score_death,answer_death,nb_homeless,score_homeless,answer_homeless,nb_injured,score_injured,answer_injured,nb_affected,score_affected,answer_affected,nb_missing,score_missing,answer_missing,nb_evacuated,score_evacuated,answer_evacuated,publication_time,extracted_location,ner_score,latitude,longitude,std_dev,min_lat,max_lat,min_lon,max_lon,n_locations,nb_death_min,nb_death_max,nb_homeless_min,nb_homeless_max,nb_injured_min,nb_injured_max,nb_affected_min,nb_affected_max,nb_missing_min,nb_missing_max,nb_evacuated_min,nb_evacuated_max,unnamed_column,country)
FROM 'C:/Mailys/data/S20200101000000_E20240101000000_GDELT_Paragraphs_v3.csv'
DELIMITER ',' 
CSV HEADER
QUOTE '"';

DELETE FROM paragraphs2020_23 WHERE longitude IS NULL;
UPDATE paragraphs2020_23 SET wkt=concat('POINT (',longitude,' ',latitude,')');
UPDATE paragraphs2020_23 SET geom=ST_GeomFromText(wkt);
UPDATE paragraphs2020_23 SET country_found = c.admin FROM countries c WHERE ST_Contains(c.geom, paragraphs2020_23.geom);


Table de jointure :

-- Table: public.event_paragraphs

DROP TABLE IF EXISTS public.event_paragraphs;

CREATE TABLE IF NOT EXISTS public.event_paragraphs
(
    event_id character varying(50) COLLATE pg_catalog."default" NOT NULL,
    paragraph_id character varying(50) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT event_paragraphs_pkey PRIMARY KEY (event_id, paragraph_id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.event_paragraphs
    OWNER to postgres;

-- Index: event_paragraphs_event_id_idx

DROP INDEX IF EXISTS public.event_paragraphs_event_id_idx;

CREATE INDEX IF NOT EXISTS event_paragraphs_event_id_idx
    ON public.event_paragraphs USING btree
    (event_id COLLATE pg_catalog."default" ASC NULLS LAST)
    WITH (deduplicate_items=True)
    TABLESPACE pg_default;

-- Index: event_paragraphs_paragraph_id_idx

DROP INDEX IF EXISTS public.event_paragraphs_paragraph_id_idx;

CREATE INDEX IF NOT EXISTS event_paragraphs_paragraph_id_idx
    ON public.event_paragraphs USING btree
    (paragraph_id COLLATE pg_catalog."default" ASC NULLS LAST)
    WITH (deduplicate_items=True)
    TABLESPACE pg_default;

INSERT INTO event_paragraphs (event_id, paragraph_id)
SELECT event_id, UNNEST(string_to_array(regexp_replace(paragraphs_list,'''|\(|\)|\s','','g'),',')::varchar[])
FROM public.events2020_23;


Table events :

-- Table: public.events

DROP TABLE IF EXISTS public.events;

-- Enlever colonnes inutiles : id_integer, wkt, paragraphs_list, articles_list
SELECT event_id, hazard_type, disaster_score, hasard_type_score, latitude, longitude, event_time, bbox_event, n_languages, n_source_countries, n_paragraphs, n_articles, start_time, end_time, duration, mostfreq_death, n_mostfreq_death, time_mostfreq_death, max_death, n_max_death, time_max_death, median_death, mostfreq_homeless, n_mostfreq_homeless, time_mostfreq_homeless, max_homeless, n_max_homeless, time_max_homeless, median_homeless, mostfreq_injured, n_mostfreq_injured, time_mostfreq_injured, max_injured, n_max_injured, time_max_injured, median_injured, mostfreq_affected, n_mostfreq_affected, time_mostfreq_affected, max_affected, n_max_affected, time_max_affected, median_affected, mostfreq_missing, n_mostfreq_missing, time_mostfreq_missing, max_missing, n_max_missing, time_max_missing, median_missing, mostfreq_evacuated, n_mostfreq_evacuated, time_mostfreq_evacuated, max_evacuated, n_max_evacuated, time_max_evacuated, median_evacuated, country, geom, primary_key, country_found
INTO events
FROM public.events2020_23;

-- Index: events_geom_idx

DROP INDEX IF EXISTS public.events_geom_idx;

CREATE INDEX IF NOT EXISTS events_geom_idx
    ON public.events USING gist
    (geom)
    WITH (buffering=auto)
    TABLESPACE pg_default;



SELECT p.*
FROM paragraphs2020_23 p
JOIN event_paragraphs ep ON p.paragraph_id = ep.paragraph_id
WHERE ep.event_id = '20200218E933CT20250417122827';


1. Utiliser des virtual tables (vues SQL) dans GeoServer

GeoServer permet de créer une couche basée sur une vue SQL avec jointure dans le fichier virtual table. Tu définis toi-même une jointure SQL entre tables.
Exemple :

SELECT 
    e.event_id,
    p.paragraph_id,
    p.text
FROM 
    events2020_23_array e
JOIN 
    paragraphs2020_23 p 
ON 
    p.paragraph_id = ANY(e.paragraphs_array)

Ensuite tu publies cette requête comme une nouvelle couche dans GeoServer (via featuretype -> SQL view), et tu peux interroger cette couche directement comme une couche GeoServer classique.

👉 C'est la meilleure solution si tu veux vraiment encapsuler la logique de jointure côté GeoServer.
2. Utiliser WFS 2.0 avec Join (complexe et rarement utilisé)

GeoServer WFS 2.0 peut supporter des requêtes complexes avec jointures en XML comme ci-dessous :

<wfs:Query typeNames="webGIS:paragraphs2020_23">
    <fes:Filter>
        <fes:PropertyIsEqualTo>
            <fes:ValueReference>paragraph_id</fes:ValueReference>
            <fes:ValueReference>webGIS:events2020_23_array/paragraphs_array</fes:ValueReference>
        </fes:PropertyIsEqualTo>
    </fes:Filter>
</wfs:Query>

⚠️ Ce n’est pas supporté en CQL, et c’est compliqué à implémenter via des appels AJAX ou dans des interfaces simples.
3. viewparams : transmettre des variables à une requête SQL préconfigurée

Si tu définis une vue SQL dans GeoServer comme :

SELECT * FROM paragraphs2020_23 WHERE paragraph_id = ANY(
    SELECT paragraphs_array FROM events2020_23_array WHERE event_id = :eventid
)

Tu peux ensuite l'appeler comme :

let url = "http://localhost:8080/geoserver/webGIS/ows?" +
    "service=WFS&version=1.1.0&request=GetFeature" +
    "&typeName=webGIS:paragraphs_from_event" + // la vue
    "&outputFormat=application/json" +
    "&viewparams=" + encodeURIComponent("eventid:20220628E8979CT20250417122827");

Oui, tu peux faire des jointures entre couches dans GeoServer en configurant une vue SQL (virtual table). C’est la façon propre et maintenable de gérer ta logique de lien entre events et paragraphs.

Souhaites-tu que je t’aide à :

    Rédiger la SQL complète pour la vue ?

    Créer le fichier virtual table pour GeoServer ?

    Lister les étapes dans GeoServer pour configurer cette couche ?