PostgreSQL path : C:\Program Files\PostgreSQL\17
password : password
port : 5432

create extension POSTGIS;

Ajouter couche pays : ne_10m_admin_0_countries.shp (Natural Earth)

Ajouter dans pg Admin :
dans l'invite de commande : 
cd C:\Program Files\PostgreSQL\17\bin
shp2pgsql -s 4326 -c -D -i -I C:\Mailys\data\ne_10m_admin_0_countries\ne_10m_admin_0_countries.shp countries | psql -h localhost -U postgres -d webGIS



Events v3 :

-- Table: public.events2020_23

DROP TABLE IF EXISTS public.events2020_23;

CREATE TABLE IF NOT EXISTS public.events2020_23
(
    id_integer integer,
    event_id character varying COLLATE pg_catalog."default",
    hazard_type character varying COLLATE pg_catalog."default",
    disaster_score real,
    hasard_type_score real,
    latitude real,
    longitude real,
    event_time timestamp without time zone,
    bbox_event character varying COLLATE pg_catalog."default",
    n_languages real,
    n_source_countries real,
    paragraphs_list character varying COLLATE pg_catalog."default",
    articles_list character varying COLLATE pg_catalog."default",
    n_paragraphs real,
    n_articles real,
    start_time timestamp without time zone,
    end_time timestamp without time zone,
    duration integer,
    mostfreq_death real,
    n_mostfreq_death real,
    time_mostfreq_death real,
    max_death real,
    n_max_death real,
    time_max_death real,
    median_death real,
    mostfreq_homeless real,
    n_mostfreq_homeless real,
    time_mostfreq_homeless real,
    max_homeless real,
    n_max_homeless real,
    time_max_homeless real,
    median_homeless real,
    mostfreq_injured real,
    n_mostfreq_injured real,
    time_mostfreq_injured real,
    max_injured real,
    n_max_injured real,
    time_max_injured real,
    median_injured real,
    mostfreq_affected real,
    n_mostfreq_affected real,
    time_mostfreq_affected real,
    max_affected real,
    n_max_affected real,
    time_max_affected real,
    median_affected real,
    mostfreq_missing real,
    n_mostfreq_missing real,
    time_mostfreq_missing real,
    max_missing real,
    n_max_missing real,
    time_max_missing real,
    median_missing real,
    mostfreq_evacuated real,
    n_mostfreq_evacuated real,
    time_mostfreq_evacuated real,
    max_evacuated real,
    n_max_evacuated real,
    time_max_evacuated real,
    median_evacuated real,
    country character varying COLLATE pg_catalog."default",
    wkt character varying COLLATE pg_catalog."default",
    geom geometry(Point,4326),
    primary_key integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    country_found character varying COLLATE pg_catalog."default",
    CONSTRAINT events2020_23_pkey PRIMARY KEY (primary_key)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.events2020_23
    OWNER to postgres;

-- Index: events2020_23_geom_idx

DROP INDEX IF EXISTS public.events2020_23_geom_idx;

CREATE INDEX IF NOT EXISTS events2020_23_geom_idx
    ON public.events2020_23 USING gist
    (geom)
    WITH (buffering=auto)
    TABLESPACE pg_default;

COPY events2020_23(id_integer,event_id,hazard_type,disaster_score,hasard_type_score,latitude,longitude,event_time,bbox_event,n_languages,n_source_countries,paragraphs_list,articles_list,n_paragraphs,n_articles,start_time,end_time,duration,mostfreq_death,n_mostfreq_death,time_mostfreq_death,max_death,n_max_death,time_max_death,median_death,mostfreq_homeless,n_mostfreq_homeless,time_mostfreq_homeless,max_homeless,n_max_homeless,time_max_homeless,median_homeless,mostfreq_injured,n_mostfreq_injured,time_mostfreq_injured,max_injured,n_max_injured,time_max_injured,median_injured,mostfreq_affected,n_mostfreq_affected,time_mostfreq_affected,max_affected,n_max_affected,time_max_affected,median_affected,mostfreq_missing,n_mostfreq_missing,time_mostfreq_missing,max_missing,n_max_missing,time_max_missing,median_missing,mostfreq_evacuated,n_mostfreq_evacuated,time_mostfreq_evacuated,max_evacuated,n_max_evacuated,time_max_evacuated,median_evacuated,country)
FROM 'C:/Mailys/data/S20200101000000_E20240101000000_GDELT_Events_v3.csv'
DELIMITER ',' 
CSV HEADER
QUOTE '"';

UPDATE events2020_23 SET wkt=concat('POINT (',longitude,' ',latitude,')');
UPDATE events2020_23 SET geom=ST_GeomFromText(wkt);
UPDATE events2020_23 SET country_found = c.admin FROM countries c WHERE ST_Contains(c.geom, events2020_23.geom);


Paragraphs v3 :

-- Table: public.paragraphs2020_23

DROP TABLE IF EXISTS public.paragraphs2020_23;

CREATE TABLE IF NOT EXISTS public.paragraphs2020_23
(
    article_id character varying COLLATE pg_catalog."default",
    title character varying COLLATE pg_catalog."default",
    extracted_text character varying COLLATE pg_catalog."default",
    paragraph_time timestamp without time zone,
    article_language character varying COLLATE pg_catalog."default",
    source_country character varying COLLATE pg_catalog."default",
    domain_url character varying COLLATE pg_catalog."default",
    paragraph_id character varying COLLATE pg_catalog."default",
    original_text character varying COLLATE pg_catalog."default",
    disaster_label real,
    disaster_score real,
    hasard_type character varying COLLATE pg_catalog."default",
    hasard_type_score real,
    nb_death real,
    score_death real,
    answer_death character varying COLLATE pg_catalog."default",
    nb_homeless real,
    score_homeless real,
    answer_homeless character varying COLLATE pg_catalog."default",
    nb_injured real,
    score_injured real,
    answer_injured character varying COLLATE pg_catalog."default",
    nb_affected real,
    score_affected real,
    answer_affected character varying COLLATE pg_catalog."default",
    nb_missing real,
    score_missing real,
    answer_missing character varying COLLATE pg_catalog."default",
    nb_evacuated real,
    score_evacuated real,
    answer_evacuated character varying COLLATE pg_catalog."default",
    publication_time timestamp without time zone,
    extracted_location character varying COLLATE pg_catalog."default",
    ner_score character varying COLLATE pg_catalog."default",
    latitude real,
    longitude real,
    std_dev real,
    min_lat real,
    max_lat real,
    min_lon real,
    max_lon real,
    n_locations real,
    nb_death_min real,
    nb_death_max real,
    nb_homeless_min real,
    nb_homeless_max real,
    nb_injured_min real,
    nb_injured_max real,
    nb_affected_min real,
    nb_affected_max real,
    nb_missing_min real,
    nb_missing_max real,
    nb_evacuated_min real,
    nb_evacuated_max real,
    unnamed_column real,
    country character varying COLLATE pg_catalog."default",
    wkt character varying COLLATE pg_catalog."default",
    geom geometry(Point,4326),
    primary_key integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    country_found character varying COLLATE pg_catalog."default",
    CONSTRAINT paragraphs2020_23_pkey PRIMARY KEY (primary_key)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.paragraphs2020_23
    OWNER to postgres;
	
-- Index: paragraphs2020_23_geom_idx

DROP INDEX IF EXISTS public.paragraphs2020_23_geom_idx;

CREATE INDEX IF NOT EXISTS paragraphs2020_23_geom_idx
    ON public.paragraphs2020_23 USING gist
    (geom)
    WITH (buffering=auto)
    TABLESPACE pg_default;
	
-- Index: paragraphs2020_23_paragraph_id_idx

DROP INDEX IF EXISTS public.paragraphs2020_23_paragraph_id_idx;

CREATE INDEX IF NOT EXISTS paragraphs2020_23_paragraph_id_idx
    ON public.paragraphs2020_23 USING btree
    (paragraph_id ASC NULLS LAST)
    TABLESPACE pg_default;

COPY paragraphs2020_23(article_id,title,extracted_text,paragraph_time,article_language,source_country,domain_url,paragraph_id,original_text,disaster_label,disaster_score,hasard_type,hasard_type_score,nb_death,score_death,answer_death,nb_homeless,score_homeless,answer_homeless,nb_injured,score_injured,answer_injured,nb_affected,score_affected,answer_affected,nb_missing,score_missing,answer_missing,nb_evacuated,score_evacuated,answer_evacuated,publication_time,extracted_location,ner_score,latitude,longitude,std_dev,min_lat,max_lat,min_lon,max_lon,n_locations,nb_death_min,nb_death_max,nb_homeless_min,nb_homeless_max,nb_injured_min,nb_injured_max,nb_affected_min,nb_affected_max,nb_missing_min,nb_missing_max,nb_evacuated_min,nb_evacuated_max,unnamed_column,country)
FROM 'C:/Mailys/data/S20200101000000_E20240101000000_GDELT_Paragraphs_v3.csv'
DELIMITER ',' 
CSV HEADER
QUOTE '"';

DELETE FROM paragraphs2020_23 WHERE longitude IS NULL;
UPDATE paragraphs2020_23 SET wkt=concat('POINT (',longitude,' ',latitude,')');
UPDATE paragraphs2020_23 SET geom=ST_GeomFromText(wkt);
UPDATE paragraphs2020_23 SET country_found = c.admin FROM countries c WHERE ST_Contains(c.geom, paragraphs2020_23.geom);


Table de jointure :

-- Table: public.event_paragraphs

DROP TABLE IF EXISTS public.event_paragraphs;

CREATE TABLE IF NOT EXISTS public.event_paragraphs
(
    event_id character varying(50) COLLATE pg_catalog."default" NOT NULL,
    paragraph_id character varying(50) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT event_paragraphs_pkey PRIMARY KEY (event_id, paragraph_id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.event_paragraphs
    OWNER to postgres;

-- Index: event_paragraphs_event_id_idx

DROP INDEX IF EXISTS public.event_paragraphs_event_id_idx;

CREATE INDEX IF NOT EXISTS event_paragraphs_event_id_idx
    ON public.event_paragraphs USING btree
    (event_id COLLATE pg_catalog."default" ASC NULLS LAST)
    WITH (deduplicate_items=True)
    TABLESPACE pg_default;

-- Index: event_paragraphs_paragraph_id_idx

DROP INDEX IF EXISTS public.event_paragraphs_paragraph_id_idx;

CREATE INDEX IF NOT EXISTS event_paragraphs_paragraph_id_idx
    ON public.event_paragraphs USING btree
    (paragraph_id COLLATE pg_catalog."default" ASC NULLS LAST)
    WITH (deduplicate_items=True)
    TABLESPACE pg_default;

INSERT INTO event_paragraphs (event_id, paragraph_id)
SELECT event_id, UNNEST(string_to_array(regexp_replace(paragraphs_list,'''|\(|\)|\s','','g'),',')::varchar[])
FROM public.events2020_23;


Table events :

-- Table: public.events

DROP TABLE IF EXISTS public.events;

-- Enlever colonnes inutiles : id_integer, wkt, paragraphs_list, articles_list
SELECT event_id, hazard_type, disaster_score, hasard_type_score, latitude, longitude, event_time, bbox_event, n_languages, n_source_countries, n_paragraphs, n_articles, start_time, end_time, duration, mostfreq_death, n_mostfreq_death, time_mostfreq_death, max_death, n_max_death, time_max_death, median_death, mostfreq_homeless, n_mostfreq_homeless, time_mostfreq_homeless, max_homeless, n_max_homeless, time_max_homeless, median_homeless, mostfreq_injured, n_mostfreq_injured, time_mostfreq_injured, max_injured, n_max_injured, time_max_injured, median_injured, mostfreq_affected, n_mostfreq_affected, time_mostfreq_affected, max_affected, n_max_affected, time_max_affected, median_affected, mostfreq_missing, n_mostfreq_missing, time_mostfreq_missing, max_missing, n_max_missing, time_max_missing, median_missing, mostfreq_evacuated, n_mostfreq_evacuated, time_mostfreq_evacuated, max_evacuated, n_max_evacuated, time_max_evacuated, median_evacuated, country, geom, primary_key, country_found
INTO events
FROM public.events2020_23;

-- Index: events_geom_idx

DROP INDEX IF EXISTS public.events_geom_idx;

CREATE INDEX IF NOT EXISTS events_geom_idx
    ON public.events USING gist
    (geom)
    WITH (buffering=auto)
    TABLESPACE pg_default;



SELECT p.*
FROM paragraphs2020_23 p
JOIN event_paragraphs ep ON p.paragraph_id = ep.paragraph_id
WHERE ep.event_id = '20200218E933CT20250417122827';


1. Utiliser des virtual tables (vues SQL) dans GeoServer

GeoServer permet de crÃ©er une couche basÃ©e sur une vue SQL avec jointure dans le fichier virtual table. Tu dÃ©finis toi-mÃªme une jointure SQL entre tables.
Exemple :

SELECT 
    e.event_id,
    p.paragraph_id,
    p.text
FROM 
    events2020_23_array e
JOIN 
    paragraphs2020_23 p 
ON 
    p.paragraph_id = ANY(e.paragraphs_array)

Ensuite tu publies cette requÃªte comme une nouvelle couche dans GeoServer (via featuretype -> SQL view), et tu peux interroger cette couche directement comme une couche GeoServer classique.

ğŸ‘‰ C'est la meilleure solution si tu veux vraiment encapsuler la logique de jointure cÃ´tÃ© GeoServer.
2. Utiliser WFS 2.0 avec Join (complexe et rarement utilisÃ©)

GeoServer WFS 2.0 peut supporter des requÃªtes complexes avec jointures en XML comme ci-dessous :

<wfs:Query typeNames="webGIS:paragraphs2020_23">
    <fes:Filter>
        <fes:PropertyIsEqualTo>
            <fes:ValueReference>paragraph_id</fes:ValueReference>
            <fes:ValueReference>webGIS:events2020_23_array/paragraphs_array</fes:ValueReference>
        </fes:PropertyIsEqualTo>
    </fes:Filter>
</wfs:Query>

âš ï¸ Ce nâ€™est pas supportÃ© en CQL, et câ€™est compliquÃ© Ã  implÃ©menter via des appels AJAX ou dans des interfaces simples.
3. viewparams : transmettre des variables Ã  une requÃªte SQL prÃ©configurÃ©e

Si tu dÃ©finis une vue SQL dans GeoServer comme :

SELECT * FROM paragraphs2020_23 WHERE paragraph_id = ANY(
    SELECT paragraphs_array FROM events2020_23_array WHERE event_id = :eventid
)

Tu peux ensuite l'appeler comme :

let url = "http://localhost:8080/geoserver/webGIS/ows?" +
    "service=WFS&version=1.1.0&request=GetFeature" +
    "&typeName=webGIS:paragraphs_from_event" + // la vue
    "&outputFormat=application/json" +
    "&viewparams=" + encodeURIComponent("eventid:20220628E8979CT20250417122827");

Oui, tu peux faire des jointures entre couches dans GeoServer en configurant une vue SQL (virtual table). Câ€™est la faÃ§on propre et maintenable de gÃ©rer ta logique de lien entre events et paragraphs.

Souhaites-tu que je tâ€™aide Ã  :

    RÃ©diger la SQL complÃ¨te pour la vue ?

    CrÃ©er le fichier virtual table pour GeoServer ?

    Lister les Ã©tapes dans GeoServer pour configurer cette couche ?